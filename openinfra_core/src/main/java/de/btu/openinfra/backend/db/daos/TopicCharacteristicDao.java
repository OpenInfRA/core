package de.btu.openinfra.backend.db.daos;

import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

import com.fasterxml.jackson.databind.ObjectMapper;

import de.btu.openinfra.backend.db.jpa.model.MetaData;
import de.btu.openinfra.backend.db.jpa.model.Project;
import de.btu.openinfra.backend.db.jpa.model.PtLocale;
import de.btu.openinfra.backend.db.jpa.model.TopicCharacteristic;
import de.btu.openinfra.backend.db.pojos.TopicCharacteristicPojo;

/**
 * This class represents the TopicCharacteristic and is used to access the
 * underlying layer generated by JPA.
 *
 * TODO this class is also very special.. verify that it fits to the new generic
 * class!
 *
 * @author <a href="http://www.b-tu.de">BTU</a> DBIS
 *
 */
public class TopicCharacteristicDao
	extends OpenInfraValueDao<TopicCharacteristicPojo,
	TopicCharacteristic, Project> {

	/**
	 * This is the required constructor which calls the super constructor and
	 * in turn creates the corresponding entity manager.
	 *
	 * @param currentProjectId the current project id (this should be null when
	 *                         the system schema is selected)
	 * @param schema           the required schema
	 */
	public TopicCharacteristicDao(
			UUID currentProjectId,
			OpenInfraSchemas schema) {
		super(currentProjectId, schema,
				TopicCharacteristic.class, Project.class);
	}

	/**
	 * This method reads a list of TopicCharacteristicPojo objects depending on
	 * the required schema (system or project). Since the system schema doesn't
	 * provide the project_id column it is necessary to handle this request
	 * separately.
	 *
	 * @param locale  A Java.util locale object.
	 * @param offset  the number where to start
	 * @param size    the size of items to provide
	 * @return        a list of TopicCharacteristicPojo objects
	 */
	@Override
	@SuppressWarnings("unchecked")
	public List<TopicCharacteristicPojo> read(
			Locale locale,
			int offset,
			int size) {
		// 1. Define a list of TopicCharacteristics
		List<TopicCharacteristic> tcList = null;
		// 2. Create an instance of this list depending on the required schema
		switch (schema) {
		// 2.a Create a native query in order to get a list of topic
		//     characteristics referring to the system schema. This causes an
		//     unsafe type conversion.
		case SYSTEM:
			tcList = em.createNativeQuery(
					"select id, description, topic "
					+ "from topic_characteristic",
					TopicCharacteristic.class).getResultList();
			break;
		// 2.b Create a named query in order to get a list of topic
		//    characteristics referring to the project schema.
		case PROJECTS:
			// fall through
		default:
			tcList = em.createNamedQuery(
					"TopicCharacteristic.findAll",
					TopicCharacteristic.class)
					.setFirstResult(offset)
					.setMaxResults(size)
					.getResultList();
			break;
		}

		// 3. Create a list which holds the pojos.
		List<TopicCharacteristicPojo> pojoList =
				new LinkedList<TopicCharacteristicPojo>();
		// 4. Map the TopicCharacteristic objects into TopicCharacteristicPojos
		for(TopicCharacteristic tc : tcList) {
			pojoList.add(mapToPojo(locale, tc));
		}
		return pojoList;
	}

	/**
	 * This method reads a specific TopicCharacteristicPojo object from database
	 * depending on the required schema (system or project). Since the system
	 * schema doesn't provide the project_id column it is necessary to handle
	 * this request separately.
	 *
	 * @param id the id of the specific TopicCharacteristic
	 * @return   the specific TopicCharacteristicPojo
	 */
	@Override
	public TopicCharacteristicPojo read(Locale locale, UUID id) {

		switch (schema) {
		case SYSTEM:
			return mapToPojo(
					locale,
					(TopicCharacteristic)em.createNativeQuery(
							"select id, description, topic "
							+ "from topic_characteristic where id = ?",
							TopicCharacteristic.class)
							.setParameter(1, id)
							.getSingleResult());
		case PROJECTS:
			// fall through
		default:
			return mapToPojo(
					locale,
					em.find(TopicCharacteristic.class, id));
		} // end switch case
	}

	/**
	 * This method returns a list of topic characteristics based on a text
	 * filter (wildcard: %).
	 *
	 * @param locale the locale
	 * @param filter the filter as text
	 * @return       an ordered list of topic characteristics
	 */
	public List<TopicCharacteristicPojo> read(Locale locale, String filter) {
		// 1. Get the currently required locale object
		PtLocale pl = new PtLocaleDao(currentProjectId, schema).read(locale);
		// 2. Get the TopicCharacteristics (the logic is embedded in the
		//    named query)
		List<TopicCharacteristic> tcs =
				em.createNamedQuery(
						"TopicCharacteristic.findByDescription",
						TopicCharacteristic.class)
						.setParameter("value", pl)
						.setParameter("filter", filter)
						.getResultList();
		// 3. Map the model objects to POJOs
		List<TopicCharacteristicPojo> tcp =
				new LinkedList<TopicCharacteristicPojo>();
		for(TopicCharacteristic tc : tcs) {
			tcp.add(TopicCharacteristicDao.mapToPojoStatically(
					locale,
					tc,
					em.find(MetaData.class, tc.getId())));
		} // end for
		return tcp;
	}

	@Override
	public TopicCharacteristicPojo mapToPojo(
			Locale locale,
			TopicCharacteristic tc) {
		return mapToPojoStatically(
				locale,
				tc,
				em.find(MetaData.class, tc.getId()));
	}

	/**
	 * This method implements the method mapToPojo in a static way.
	 *
	 * @param locale the requested language as Java.util locale
	 * @param tc    the model object
	 * @return       the POJO object when the model object is not null else null
	 */
	@SuppressWarnings("unchecked")
	public static TopicCharacteristicPojo mapToPojoStatically(
			Locale locale,
			TopicCharacteristic tc,
			MetaData md) {
		TopicCharacteristicPojo pojo = new TopicCharacteristicPojo();

		if(md != null) {
			ObjectMapper om = new ObjectMapper();
			try {
				pojo.setSettings(om.readValue(md.getData(), List.class));
			} catch (Exception ex) {
				ex.printStackTrace();
			} // end try catch
		} // end if

		pojo.setTopic(ValueListValueDao.mapToPojoStatically(
				locale,
				tc.getValueListValue()));
		pojo.setDescriptions(DescriptionDao.mapToPojoStatically(
				locale,
				tc.getPtFreeText()));
		pojo.setUuid(tc.getId());

		return pojo;
	}

	@Override
	public MappingResult<TopicCharacteristic> mapToModel(
			TopicCharacteristicPojo pojo,
			TopicCharacteristic tc) {

        // return null if the pojo is null
        if (pojo != null) {

            // TODO set the model values

            // return the model as mapping result
            return new MappingResult<TopicCharacteristic>(tc.getId(), tc);
        } else {
            return null;
        }
	}

}
